<?php

namespace TMG\Api\ApiBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\Common\Collections\ArrayCollection;
use DateTime;
use Doctrine\ORM\QueryBuilder;
use TMG\Api\ApiBundle\Entity\Property;

/**
 * ContractRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ContractRepository extends EntityRepository
{

    private $inviableCollectionMessages = [
        'CA',
    ];

    private $eightHundredProductCodes = array(
        'HTCIT800',
        'TMG800',
        'HTCIT800R',
        'TMG800R',
        '6TMG800',
        '6TMG800R',
    );

    private $socialProductCodes = array(
        '6MYSOCIALPRO',
        '6PREMIUMSOCIAL',
        '6FEATUREDSOCIAL',
        '6DIGITALPRO',
        '6WEBPROPRESOCIAL',
        '6WEBPROFEATSOCIAL',
        '6MARKETINGPRO',
        'MYSOCIAL',
        'MYSOCIALPRO',
        'PREMIUMSOCIAL',
        'FEATUREDSOCIAL',
        'DIGITALPRO',
        'WEBPROPRESOCIAL',
        'WEBPROFEATSOCIAL',
        'MARKETINGPRO',
    );

    public $resolveProductCodes = array(
        'TMGRR',
        'TMGRR1',
        'TMGRR2',
        'TMGRRB15',
        'TMGRRB30',
    );

    public $reputationProductCodes = array(
        'WDPRSA',
        '6WDPRSA',
        'WDPRBT',
        '6WDPRBT',
        'WDPRRM',
        '6WDPRRM',
    );

    /**
     * @param array $products
     * @return array
     */
    public function findActiveContractsByProducts(array $products)
    {
        $queryBuilder = $this
            ->createQueryBuilder('c');

        $queryBuilder
            ->select('c.id')
            ->where('c.startDate <= :now')
            ->andWhere('c.endDate > :now')
            ->andWhere(
                $queryBuilder->expr()->orX(
                    'c.collectionMessage IS NULL',
                    'c.collectionMessage NOT IN (:inviableCollectionMessages)'
                )
            )
            ->andWhere('c.property IS NOT NULL')
            ->setParameter('inviableCollectionMessages', $this->inviableCollectionMessages)
            ->setParameter('now', new DateTime('now'));

        $queryBuilder
            ->andWhere('c.product IN (:products)')
            ->setParameter('products', $products);

        return $queryBuilder->getQuery()->getResult();
    }

    /**
     * @param DateTime $date
     * @param array    $products
     * @param Property $property
     *
     * @return array
     */
    public function findActiveContractsForDate(DateTime $date, array $products = [], $property = null)
    {
        $queryBuilder = $this
            ->createQueryBuilder('c');

        $queryBuilder
            ->andWhere('c.startDate <= :date')
            ->andWhere('c.endDate > :date')
            ->andWhere(
                $queryBuilder->expr()->orX(
                    'c.collectionMessage IS NULL',
                    'c.collectionMessage NOT IN (:inviableCollectionMessages)'
                )
            )
            ->setParameter('date', $date)
            ->setParameter('inviableCollectionMessages', $this->inviableCollectionMessages);

        if (count($products)) {
            $queryBuilder
                ->join('c.product', 'p')
                ->andWhere('p.code IN (:products)')
                ->setParameter('products', $products);
        }

        if ($property) {
            $queryBuilder
                ->andWhere('c.property = :property')
                ->setParameter('property', $property);
        }

        return $queryBuilder->getQuery()->getResult();
    }

    /**
     * @param DateTime $startDate
     * @param DateTime $endDate
     *
     * @return QueryBuilder
     */
    public function findActiveContractsForDateRangeQueryBuilder(DateTime $startDate, DateTime $endDate)
    {
        $queryBuilder = $this
            ->createQueryBuilder('contract');

        $queryBuilder
            ->join('contract.product', 'product')
            ->join('contract.property', 'property')
            // We want any contracts that were active at any point in the course of the date range.
            // This means we want anything that ended after the start date and started before the end date.
            ->andWhere('contract.endDate > :startDate')
            ->andWhere('contract.startDate < :endDate')
            // We should also ignore contracts for which the start date is before the end date.
            ->andWhere('contract.startDate < contract.endDate')
            // We also don't want to return contracts that are in collections.
            ->andWhere(
                $queryBuilder->expr()->orX(
                    'contract.collectionMessage IS NULL',
                    'contract.collectionMessage NOT IN (:inviableCollectionMessages)'
                )
            )
            // But we always want to return the ones that are "forced" online.
            ->orWhere('property.forceLive = true')
            ->setParameter('startDate', $startDate)
            ->setParameter('endDate', $endDate)
            ->setParameter('inviableCollectionMessages', $this->inviableCollectionMessages);

        return $queryBuilder;
    }

    public function getPremiumPositionList()
    {
        return $this->createQueryBuilder('c')
            ->select('Distinct(c.position)')
            ->where('c.position is not null')
            ->getQuery()
            ->getResult();
    }

    public function buildPremiumPositionReport($bookId, $start, $end, $position = null)
    {
        $qb = $this->createQueryBuilder('c')
            ->select(
                'prop.hash',
                'c.startIssue',
                'c.endIssue',
                'c.position',
                'c.orderNumber',
                'c.masterOrderNumber',
                'c.masterOrderAccount',
                'c.masterOrderE1Account',
                'prod.code',
                'prop.name',
                'prop.axNumber',
                'prop.propertyNumber',
                'r.name as rep'
            )
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->join('c.rep', 'r')
            ->where('c.book = :book')
            ->andWhere('prod.type = :type')
            ->andWhere('c.startIssue <= :end')
            ->andWhere('c.endIssue >= :start')
            ->orderBy('c.position', 'ASC')
            ->setParameter('book', $bookId)
            ->setParameter('type', 1)
            ->setParameter('end', $end)
            ->setParameter('start', $start);

        if ($position != '') {
            $qb = $qb->andWhere('c.position = :position')
                ->setParameter('position', $position);
        } else {
            $qb = $qb->andWhere('c.position is not null');
        }
        $results = $qb->getQuery()->getResult();

        return $results;
    }

    public function adChangeItems($bookId, $typeId, $issue)
    {
        $qb = $this->createQueryBuilder('c')
            ->select(
                'c.id',
                'c.orderNumber',
                'c.masterOrderNumber',
                'c.masterOrderAccount',
                'c.masterOrderE1Account',
                'c.startIssue',
                'c.endIssue',
                'c.position',
                'c.color',
                'prod.code',
                'prod.description',
                'prop.hash',
                'prop.axNumber',
                'prop.propertyNumber',
                'prop.name',
                'prop.phone',
                'prop.id as property',
                'r.name as rep',
                'a.line1',
                'a.city',
                'pc.code as postal',
                'st.abbreviation as state'
            )
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->join('c.rep', 'r')
            ->join('prop.address', 'a')
            ->join('a.postalCode', 'pc')
            ->join('a.state', 'st')
            ->where('c.book = :book')
            ->andWhere('prod.type = :type')
            ->andWhere('c.startIssue <= :issue')
            ->andWhere('c.endIssue >= :issue')
            ->setParameter('book', $bookId)
            ->setParameter('type', $typeId)
            ->setParameter('issue', $issue);

        /*if ($typeId == 3) {
            $qb->addSelect('tf.number')
                ->join('prop.tollFree', 'tf')
                ->andWhere('tf.type = :tfType')
                ->setParameter('tfType', 1)

        }*/
        $results = $qb->getQuery()->getResult();

        return $results;
    }

    public function adChangePreviousItem($bookId, $typeId, $propId, $issue)
    {
        $qb = $this->createQueryBuilder('c')
            ->select(
                'c.id',
                'c.orderNumber',
                'c.masterOrderNumber',
                'c.masterOrderAccount',
                'c.masterOrderE1Account',
                'c.position',
                'c.color',
                'c.startIssue',
                'c.endIssue',
                'prod.code',
                'prod.description'
            )
            ->join('c.product', 'prod')
            ->where('c.book = :book')
            ->andWhere("prod.type = :type")
            ->andWhere('c.endIssue < :issue')
            ->andWhere('c.property = :prop')
            ->andWhere('c.feedStatus = :status')
            ->setParameter('book', $bookId)
            ->setParameter('type', $typeId)
            ->setParameter('issue', $issue)
            ->setParameter('prop', $propId)
            ->setParameter('status', 'Active')
            ->orderBy('c.endIssue', 'DESC');

        /*if ($typeId == 3) {
            $qb->addSelect('tf.number')
                ->join('prop.tollFree', 'tf')
                ->andWhere('tf.type = :tfType')
                ->setParameter('tfType', 1)

        }*/

        $results = $qb->getQuery()->setMaxResults(1)->getOneOrNullResult();

        return $results;
    }

    public function adChangeDroppedItems($bookId, $typeId, $issue, $ids)
    {
        $qb = $this->createQueryBuilder('c')
            ->select(
                'c.id',
                'c.orderNumber',
                'c.masterOrderNumber',
                'c.masterOrderAccount',
                'c.masterOrderE1Account',
                'c.startIssue',
                'c.endIssue',
                'c.position',
                'c.color',
                'prod.code',
                'prod.description',
                'prop.hash',
                'prop.axNumber',
                'prop.propertyNumber',
                'prop.name',
                'prop.phone',
                'prop.id as property',
                'r.name as rep',
                'a.line1',
                'a.city',
                'pc.code as postal',
                'st.abbreviation as state'
            )
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->join('c.rep', 'r')
            ->join('prop.address', 'a')
            ->join('a.postalCode', 'pc')
            ->join('a.state', 'st')
            ->where('c.book = :book')
            ->andWhere('prod.type = :type')
            ->andWhere('c.endIssue = :issue')
            ->andWhere('c.id NOT IN (:ids)')
            ->setParameter('book', $bookId)
            ->setParameter('type', $typeId)
            ->setParameter('issue', $issue)
            ->setParameter('ids', $ids);

        /*if ($typeId == 3) {
            $qb->addSelect('tf.number')
                ->join('prop.tollFree', 'tf')
                ->andWhere('tf.type = :tfType')
                ->setParameter('tfType', 1)

        }*/
        $results = $qb->getQuery()->getResult();

        return $results;
    }

    public function nextOrderItemCount($bookId, $typeId, $propId, $issue)
    {
        return $this->createQueryBuilder('c')
            ->select('COUNT(c.id)')
            ->join('c.product', 'prod')
            ->where('c.book = :book')
            ->andWhere("prod.type = :type")
            ->andWhere('c.endIssue < :issue')
            ->andWhere('c.property = :prop')
            ->setParameter('book', $bookId)
            ->setParameter('type', $typeId)
            ->setParameter('issue', $issue)
            ->setParameter('prop', $propId)
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function missingAccountNumbersForSharedAdsCount()
    {
        return $this->createQueryBuilder('contract')
            ->select('COUNT(property.id)')
            ->join('contract.property', 'property')
            ->join('contract.product', 'product')
            ->where('product.code LIKE :product')
            ->andWhere('contract.masterOrderNumber IS NULL')
            ->andWhere('contract.masterOrderAccount IS NULL')
            ->andWhere('contract.masterOrderE1Account IS NULL')
            ->andWhere('contract.endDate > :now')
            ->setParameter('product', '%SHAR%')
            ->setParameter('now', date('Y-m-d'))
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function missingAccountNumbersForSharedAdsList()
    {
        return $this->createQueryBuilder('contract')
            ->select('p.hash as property, p.axNumber as accountNumber, contract.updatedAt as reportDate')
            ->join('contract.property', 'p')
            ->join('contract.product', 'product')
            ->where('product.code LIKE :product')
            ->andWhere('contract.masterOrderNumber IS NULL')
            ->andWhere('contract.masterOrderAccount IS NULL')
            ->andWhere('contract.masterOrderE1Account IS NULL')
            ->andWhere('contract.endDate > :now')
            ->setParameter('product', '%SHAR%')
            ->setParameter('now', date('Y-m-d'))
            ->getQuery()
            ->getResult();
    }

    /**
     * Count properties with active social contract without subdomain setup
     *
     * @return String
     */
    public function missingSubdomainCount()
    {
        return $this->createQueryBuilder('c')
            ->select('COUNT(DISTINCT prop.id)')
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->leftJoin('prop.tripStayWinData', 'tr')
            ->leftJoin('tr.subdomain', 's')
            ->where('prop.tripStayWinData IS NULL or s.subdomain = :subdomain')
            ->andWhere('prod.code IN (:codes)')
            ->andWhere('c.startDate <= :now')
            ->andWhere('c.endDate >= :now')
            ->andWhere('c.feedStatus = :status')
            ->setParameters(
                [
                    'codes' => $this->socialProductCodes,
                    'now' => date('Y-m-d'),
                    'status' => 'Active',
                    'subdomain' => '',
                ]
            )
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * List of properties with active social contract without subdomain setup
     *
     * @return ArrayCollection
     */
    public function missingSubdomainList()
    {
        return $this->createQueryBuilder('c')
            ->select('DISTINCT prop.axNumber as accountNumber, prop.hash as id, prop.name')
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->leftJoin('prop.tripStayWinData', 'tr')
            ->leftJoin('tr.subdomain', 's')
            ->where('prop.tripStayWinData IS NULL or s.subdomain = :subdomain')
            ->andWhere('prod.code IN (:codes)')
            ->andWhere('c.startDate <= :now')
            ->andWhere('c.endDate >= :now')
            ->andWhere('c.feedStatus = :status')
            ->setParameters(
                [
                    'codes' => $this->socialProductCodes,
                    'now' => date('Y-m-d'),
                    'status' => 'Active',
                    'subdomain' => '',
                ]
            )
            ->getQuery()
            ->getResult();
    }

    /**
     * Check property if has a valid online contract
     *
     * @param integer $id
     * @return boolean
     */
    public function hasOnlineContract($id)
    {
        $count = $this->createQueryBuilder('c')
            ->select('COUNT(c)')
            ->join('c.product', 'prod')
            ->join('prod.type', 't')
            ->where('c.property = :id')
            ->andWhere('t.type = :type')
            ->andWhere('c.feedStatus = :status')
            ->andWhere('c.endDate > :now')
            ->setParameter('id', $id)
            ->setParameter('type', 'online')
            ->setParameter('status', 'Active')
            ->setParameter('now', date('Y-m-d'))
            ->getQuery()
            ->getSingleScalarResult();

        return $count > 0;
    }

    /**
     * Get 800 contract product codes
     *
     * @param string $issue
     * @param string $propertyId
     * @return arrayCollection
     */
    public function get800ContractProductCodes($propertyId, $issue)
    {
        return $this->createQueryBuilder('c')
            ->select('prod.code')
            ->join('c.product', 'prod')
            ->join('c.property', 'prop')
            ->where('prop.id = :propertyId')
            ->andWhere('prod.code IN (:codes)')
            ->andWhere('c.startIssue <= :issue')
            ->andWhere('c.endIssue >= :issue')
            ->setParameter('propertyId', $propertyId)
            ->setParameter('codes', $this->eightHundredProductCodes)
            ->setParameter('issue', $issue)
            ->getQuery()
            ->getResult();
    }
}
